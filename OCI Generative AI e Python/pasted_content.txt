# ğŸ’¥ Vamos Botar Esse Agente no Ar, Mauro! (Streamlit Edition)

Perfeito! Vamos focar em **Streamlit** e preparar tudo para quando vocÃª tiver as credenciais da OCI. Aqui estÃ¡ o cÃ³digo completo e otimizado:

## ğŸ“‹ CÃ³digo Final - `app.py`

```python
import os
import sqlite3
import time
from datetime import datetime
from typing import List, Dict, Any, Optional
import streamlit as st
import pandas as pd
import plotly.express as px
from pydantic import BaseModel, Field
from dotenv import load_dotenv

# =========================
# ConfiguraÃ§Ã£o Inicial
# =========================
load_dotenv()
st.set_page_config(
    page_title="OCI Chatbot v3 â€” MemÃ³ria, Personas e Feedback", 
    page_icon="ğŸ’¬", 
    layout="centered",
    initial_sidebar_state="expanded"
)

# Estilos CSS personalizados
st.markdown("""
<style>
    .small { font-size: 0.85rem; color: #666; }
    .bubble-user { 
        background: #e1f5fe; 
        padding: 0.8rem 1rem; 
        border-radius: 1rem 1rem 0 1rem;
        margin: 0.5rem 0;
        border: 1px solid #bbdefb;
    }
    .bubble-bot { 
        background: #f3e5f5; 
        padding: 0.8rem 1rem; 
        border-radius: 1rem 1rem 1rem 0;
        margin: 0.5rem 0;
        border: 1px solid #e1bee7;
    }
    .tag { 
        display:inline-block; 
        padding: 4px 10px; 
        border-radius: 12px; 
        background:#f1f5f9; 
        margin-right:8px;
        font-size: 0.8rem;
        border: 1px solid #e2e8f0;
    }
    .metrics { 
        background: #f8f9fa; 
        padding: 1rem; 
        border-radius: 0.5rem; 
        margin: 0.5rem 0; 
        border: 1px solid #e2e8f0;
    }
    .stButton button {
        width: 100%;
        background-color: #4f46e5;
        color: white;
    }
</style>
""", unsafe_allow_html=True)

# =========================
# Personas & Estilos
# =========================
PERSONAS = {
    "Professor": "Explique com exemplos simples e analogias, seja didÃ¡tico e paciente.",
    "Suporte TÃ©cnico": "Seja objetivo, passo a passo, com troubleshooting e validaÃ§Ãµes.",
    "Contador de HistÃ³rias": "Use narrativa leve, metÃ¡foras curtas e exemplos envolventes.",
    "Analista": "ForneÃ§a dados estruturados, anÃ¡lise objetiva e insights acionÃ¡veis."
}

STYLES = {
    "Formal": "Escreva em tom profissional, claro e direto, evitando coloquialismos.",
    "TÃ©cnico": "Use termos tÃ©cnicos quando necessÃ¡rio, inclua listas numeradas e consideraÃ§Ãµes prÃ¡ticas.",
    "Simples": "Frases curtas, vocabulÃ¡rio simples, vÃ¡ direto ao ponto.",
    "EmpÃ¡tico": "Seja caloroso, encorajador e demonstre compreensÃ£o emocional."
}

# =========================
# Modelos de parÃ¢metros
# =========================
class GenParams(BaseModel):
    temperature: float = Field(0.5, ge=0.0, le=1.0)
    top_p: float = Field(0.9, ge=0.0, le=1.0)
    max_tokens: int = Field(512, ge=64, le=4096)
    memory_turns: int = Field(6, ge=0, le=20)

# =========================
# Cliente OCI (Modo SimulaÃ§Ã£o)
# =========================
class OCIClient:
    def __init__(self, mode: str = "mock"):
        self.mode = mode
        self.endpoint = os.getenv("OCI_ENDPOINT_URL", "")
        self.region = os.getenv("OCI_REGION", "")
        self.compartment = os.getenv("OCI_COMPARTMENT_OCID", "")
        
    def generate(self, messages: List[Dict[str, str]], params: GenParams) -> str:
        """Gera resposta usando modo simulaÃ§Ã£o (atÃ© vocÃª ter as credenciais OCI)"""
        return self._mock_response(messages, params)
    
    def _mock_response(self, messages: List[Dict[str, str]], params: GenParams) -> str:
        """Resposta simulada para desenvolvimento"""
        user_last = next((m["content"] for m in reversed(messages) if m["role"] == "user"), "")
        
        # Identificar persona ativa
        persona = "Assistente"
        system_msg = next((m["content"] for m in messages if m["role"] == "system"), "")
        for k in PERSONAS.keys():
            if k.lower() in system_msg.lower():
                persona = k
                break
        
        # Gerar resposta simulada baseada na persona
        responses = {
            "Professor": f"Como educador, vou explicar isso passo a passo. Primeiro, Ã© importante entender que '{user_last}' pode ser abordado de vÃ¡rias perspectivas. Vamos comeÃ§ar com os fundamentos...",
            "Suporte TÃ©cnico": f"Para resolver isso, vamos seguir um processo de troubleshooting: 1) Verifique X, 2) Confirme Y, 3) Teste Z. Isso deve resolver o problema relacionado a '{user_last}'.",
            "Contador de HistÃ³rias": f"Isso me lembra uma histÃ³ria... Era uma vez alguÃ©m que enfrentou um desafio similar a '{user_last}'. Eles descobriram que a melhor abordagem era...",
            "Analista": f"Analisando sua pergunta sobre '{user_last}', os dados mostram que 72% dos casos similares sÃ£o resolvidos com a abordagem A, 23% com B, e 5% requerem intervenÃ§Ã£o especializada.",
            "Assistente": f"Entendi sua pergunta sobre '{user_last}'. Posso ajudar com informaÃ§Ãµes detalhadas, exemplos prÃ¡ticos e orientaÃ§Ãµes passo a passo."
        }
        
        response = responses.get(persona, responses["Assistente"])
        return f"{response}\n\n*(Modo simulaÃ§Ã£o - {persona} | temp={params.temperature})*"

# =========================
# Helpers: prompt & memÃ³ria
# =========================
def build_system_prompt(persona: str, style: str) -> str:
    guardrails = (
        "Responda em PT-BR. Seja Ãºtil, claro e honesto sobre limitaÃ§Ãµes. "
        "Quando for apropriado, proponha prÃ³ximos passos prÃ¡ticos. "
        "Se a pergunta for ambÃ­gua, peÃ§a uma Ãºnica clarificaÃ§Ã£o curta. "
        "Nunca invente nÃºmeros ou polÃ­ticas internas."
    )
    return f"""VocÃª Ã© um assistente especializado com foco em {persona}. 
Persona: {PERSONAS[persona]}
Estilo: {style}. {STYLES[style]}
Regras: {guardrails}"""

def trim_history(history: List[Dict[str, str]], max_turns: int) -> List[Dict[str, str]]:
    """MantÃ©m apenas as Ãºltimas N trocas alÃ©m da mensagem de sistema."""
    system = [m for m in history if m["role"] == "system"]
    dialog = [m for m in history if m["role"] in ("user", "assistant")]
    if max_turns <= 0:
        return system
    return system + dialog[-(max_turns*2):]

# =========================
# Sistema de Banco de Dados
# =========================
def init_db():
    """Inicializa o banco de dados SQLite"""
    conn = sqlite3.connect('feedback.db')
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS feedback (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            persona TEXT,
            style TEXT,
            rating TEXT,
            comment TEXT,
            user_msg TEXT,
            assistant_msg TEXT
        )
    ''')
    conn.commit()
    conn.close()

def save_feedback_db(feedback_data: Dict[str, Any]):
    """Salva feedback no SQLite"""
    conn = sqlite3.connect('feedback.db')
    c = conn.cursor()
    c.execute('''
        INSERT INTO feedback (timestamp, persona, style, rating, comment, user_msg, assistant_msg)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    ''', (
        feedback_data.get("timestamp"),
        feedback_data.get("persona"),
        feedback_data.get("style"),
        feedback_data.get("rating"),
        feedback_data.get("comment"),
        feedback_data.get("user_msg"),
        feedback_data.get("assistant_msg")
    ))
    conn.commit()
    conn.close()

def get_feedback_data():
    """Recupera todos os dados de feedback"""
    conn = sqlite3.connect('feedback.db')
    df = pd.read_sql_query("SELECT * FROM feedback", conn)
    conn.close()
    return df

# =========================
# PÃ¡ginas do Streamlit
# =========================
def main_chat_page():
    """PÃ¡gina principal do chat"""
    st.sidebar.title("âš™ï¸ ConfiguraÃ§Ãµes")
    
    # ConfiguraÃ§Ãµes de Persona e Estilo
    persona = st.sidebar.selectbox("Persona", list(PERSONAS.keys()), index=0)
    style = st.sidebar.selectbox("Estilo", list(STYLES.keys()), index=0)
    
    st.sidebar.markdown("---")
    st.sidebar.caption("ParÃ¢metros do Modelo")
    temperature = st.sidebar.slider("Temperature", 0.0, 1.0, 0.7, 0.05, 
                                   help="Controla a criatividade: valores mais baixos = mais determinÃ­stico")
    top_p = st.sidebar.slider("Top-P", 0.0, 1.0, 0.9, 0.05, 
                             help="Controla diversidade: valores mais baixos = mais focado")
    max_tokens = st.sidebar.slider("Max tokens", 64, 2048, 512, 32,
                                  help="NÃºmero mÃ¡ximo de tokens na resposta")
    memory_turns = st.sidebar.slider("MemÃ³ria (nÂº de trocas)", 0, 20, 6, 1,
                                    help="Quantas interaÃ§Ãµes anteriores lembrar")

    st.sidebar.markdown("---")
    mock_mode = st.sidebar.toggle("Modo SimulaÃ§Ã£o (Ativo sem credenciais OCI)", value=True)
    st.sidebar.info("âœ… Modo simulaÃ§Ã£o ativo. Desative quando tiver as credenciais OCI.")

    # Inicializar cliente e parÃ¢metros
    params = GenParams(temperature=temperature, top_p=top_p, max_tokens=max_tokens, memory_turns=memory_turns)
    client = OCIClient(mode="mock" if mock_mode else "oci")

    # UI - CabeÃ§alho
    st.title("ğŸ’¬ Chatbot OCI v3")
    st.caption("Sistema de conversaÃ§Ã£o com memÃ³ria, personas e feedback - Pronto para integraÃ§Ã£o com Oracle Cloud")
    
    # Tags de configuraÃ§Ã£o
    st.markdown(
        f'<span class="tag">ğŸ§‘â€ğŸ’¼ {persona}</span>'
        f'<span class="tag">ğŸ¨ {style}</span>'
        f'<span class="tag">ğŸŒ¡ï¸ {temperature}</span>'
        f'<span class="tag">ğŸ“Š top-p={top_p}</span>'
        f'<span class="tag">ğŸ§  mem={memory_turns}</span>',
        unsafe_allow_html=True
    )

    # Inicializar estado da sessÃ£o
    if "chat_history" not in st.session_state:
        st.session_state.chat_history = []
    
    if "feedback_submitted" not in st.session_state:
        st.session_state.feedback_submitted = False
    
    # Sistema prompt inicial
    system_prompt = {"role": "system", "content": build_system_prompt(persona, style)}
    
    # Atualizar system prompt se persona/estilo mudou
    if not st.session_state.chat_history or st.session_state.chat_history[0]["role"] != "system":
        st.session_state.chat_history = [system_prompt]
    else:
        st.session_state.chat_history[0] = system_prompt

    # BotÃ£o para limpar histÃ³rico
    if st.button("ğŸ—‘ï¸ Limpar Conversa", use_container_width=True):
        st.session_state.chat_history = [system_prompt]
        st.session_state.feedback_submitted = False
        st.rerun()

    # Renderizar histÃ³rico de conversa
    for m in st.session_state.chat_history:
        if m["role"] == "user":
            with st.chat_message("user", avatar="ğŸ§‘â€ğŸ’»"):
                st.markdown(f'<div class="bubble-user">{m["content"]}</div>', unsafe_allow_html=True)
        elif m["role"] == "assistant":
            with st.chat_message("assistant", avatar="ğŸ¤–"):
                st.markdown(f'<div class="bubble-bot">{m["content"]}</div>', unsafe_allow_html=True)

    # Entrada do usuÃ¡rio
    user_msg = st.chat_input("Digite sua mensagem...")
    if user_msg:
        # Adicionar mensagem do usuÃ¡rio ao histÃ³rico
        st.session_state.chat_history.append({"role": "user", "content": user_msg})
        
        # Recortar memÃ³ria para manter apenas as Ãºltimas N trocas
        messages = trim_history(st.session_state.chat_history, params.memory_turns)
        
        # Gerar resposta
        try:
            with st.spinner("ğŸ’­ Processando sua pergunta..."):
                assistant_text = client.generate(messages, params)
                # Pequena pausa para melhor experiÃªncia do usuÃ¡rio
                time.sleep(0.5)
            
            # Adicionar resposta ao histÃ³rico
            st.session_state.chat_history.append({"role": "assistant", "content": assistant_text})
            st.session_state.feedback_submitted = False
            st.rerun()
            
        except Exception as e:
            st.error(f"âš ï¸ Erro ao gerar resposta: {e}")

    # Sistema de feedback para a Ãºltima resposta
    if (len(st.session_state.chat_history) > 2 and 
        st.session_state.chat_history[-1]["role"] == "assistant" and
        not st.session_state.feedback_submitted):
        
        last_user = st.session_state.chat_history[-2]["content"]
        last_bot = st.session_state.chat_history[-1]["content"]
        
        st.markdown("---")
        st.markdown("### ğŸ’¡ Feedback desta resposta")
        
        cols = st.columns([1, 3])
        with cols[0]:
            rating = st.radio("AvaliaÃ§Ã£o", ["ğŸ‘", "ğŸ‘"], horizontal=True, 
                             index=0, label_visibility="collapsed")
        with cols[1]:
            comment = st.text_input("ComentÃ¡rio (opcional):", 
                                   placeholder="Como podemos melhorar?")
        
        if st.button("Enviar Feedback", use_container_width=True):
            save_feedback_db({
                "timestamp": datetime.now().isoformat(),
                "persona": persona,
                "style": style,
                "rating": rating,
                "comment": comment.strip(),
                "user_msg": last_user,
                "assistant_msg": last_bot
            })
            st.session_state.feedback_submitted = True
            st.success("âœ… Feedback registrado. Obrigado!")
            st.rerun()

def analytics_page():
    """PÃ¡gina de analytics com visualizaÃ§Ãµes dos feedbacks"""
    st.title("ğŸ“Š Analytics - Feedback do Chatbot")
    
    try:
        df = get_feedback_data()
        
        if df.empty:
            st.info("ğŸ“ Ainda nÃ£o hÃ¡ dados de feedback coletados.")
            st.image("https://i.imgur.com/6NKPrhO.png", width=300)
            return
            
        # Converter timestamp para datetime
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df['date'] = df['timestamp'].dt.date
        
        # MÃ©tricas gerais
        total_feedbacks = len(df)
        positive_feedbacks = len(df[df['rating'] == 'ğŸ‘'])
        negative_feedbacks = len(df[df['rating'] == 'ğŸ‘'])
        satisfaction_rate = (positive_feedbacks / total_feedbacks * 100) if total_feedbacks > 0 else 0
        
        col1, col2, col3, col4 = st.columns(4)
        col1.metric("Total Feedbacks", total_feedbacks)
        col2.metric("ğŸ‘ Positivos", positive_feedbacks)
        col3.metric("ğŸ‘ Negativos", negative_feedbacks)
        col4.metric("Taxa de SatisfaÃ§Ã£o", f"{satisfaction_rate:.1f}%")
        
        st.markdown("---")
        
        # GrÃ¡ficos
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("DistribuiÃ§Ã£o por Persona")
            persona_counts = df['persona'].value_counts()
            fig_persona = px.pie(
                values=persona_counts.values, 
                names=persona_counts.index,
                color_discrete_sequence=px.colors.sequential.Plasma
            )
            st.plotly_chart(fig_persona, use_container_width=True)
            
        with col2:
            st.subheader("AvaliaÃ§Ã£o por Persona")
            rating_by_persona = pd.crosstab(df['persona'], df['rating'])
            fig_rating_persona = px.bar(
                rating_by_persona, 
                barmode='group',
                color_discrete_sequence=['#ff4b4b', '#4bb543']
            )
            st.plotly_chart(fig_rating_persona, use_container_width=True)
        
        # ComentÃ¡rios
        st.subheader("ğŸ“ ComentÃ¡rios dos UsuÃ¡rios")
        comments_df = df[df['comment'].notna() & (df['comment'] != '')][['timestamp', 'persona', 'rating', 'comment']]
        
        if not comments_df.empty:
            for _, row in comments_df.iterrows():
                with st.expander(f"{row['timestamp']} - {row['persona']} - {row['rating']}"):
                    st.write(row['comment'])
        else:
            st.info("Nenhum comentÃ¡rio foi registrado ainda.")
            
    except Exception as e:
        st.error(f"Erro ao carregar dados: {e}")

# =========================
# App principal
# =========================
def main():
    # Inicializar banco de dados
    init_db()
    
    # NavegaÃ§Ã£o entre pÃ¡ginas
    st.sidebar.title("NavegaÃ§Ã£o")
    page = st.sidebar.radio("Selecione a pÃ¡gina:", ["ğŸ’¬ Chat", "ğŸ“Š Analytics"])
    
    # InformaÃ§Ãµes da OCI na sidebar
    st.sidebar.markdown("---")
    st.sidebar.subheader("ğŸ”§ ConfiguraÃ§Ã£o OCI")
    st.si
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)